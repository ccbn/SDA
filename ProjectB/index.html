<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>D3 Page Template</title>
        <script type="text/javascript" src="d3.js"></script>
        <link rel="stylesheet" href="css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <style>
          .h2
          {
            font-family: Georgia;
            font-weight: bold;
            font-size: 36px;
          }
          .p-custom
          {
            font-family: Georgia;
            font-size: 14px;
            line-height: 1.6em;
          }
          .line
          {
            stroke: blue;
            fill: none;
          }
          .tooltip
          {
            border: 1px solid black;
            border-radius: 5px;
            padding: 5px;
            color: black;
            background-color: white;
            position: absolute;
            pointer-events: none;
          }
          svg
          {
            display: block;
            margin: auto;
          }
        </style>
    </head>
    <body>
      <div id=scatter></div>
      <div id=timeline></div>
      <div id=map></div>
        <script type="text/javascript">
        var colors = ["blue", "teal", "brown", "pink", "purple"];
        var width = window.innerWidth*0.6;
        var height = window.innerWidth*0.6;

        function createTooltip() {
          var toolTip = d3.select("#scatter").append("div")
              .attr("class", "tooltip")
              .style("opacity", 0);
          return toolTip;
        }

        function loadTimeline(dataset,projection,svgMap,toolTip) {
          var width = window.innerWidth;
          var height = 250;
          var padding = 30;

          var NumberOfInspectionsPerDay = d3.nest()
                .key(function(d) { return d.InspectionDate})
                .rollup(function(v) {return v.length})
                .entries(dataset);

          for (var i = 0; i < NumberOfInspectionsPerDay.length; i++) {
            NumberOfInspectionsPerDay[i].key = new Date(NumberOfInspectionsPerDay[i].key)
          }

          var xScale = d3.scaleTime()
                      .domain([
                        d3.min(NumberOfInspectionsPerDay, function(d) { return d.key;}),
                        d3.max(NumberOfInspectionsPerDay, function(d) { return d.key;})
                      ])
                      .range([padding, width - padding]);

          var yScale = d3.scaleLinear()
                      .domain([
                        d3.min(NumberOfInspectionsPerDay, function(d) { return d.value;}),
                        d3.max(NumberOfInspectionsPerDay, function(d) { return d.value;})
                      ])
                      .range([height - padding, padding]);

          var xAxis = d3.axisBottom()
                      .scale(xScale)
                      .ticks(10);

          var yAxis = d3.axisLeft()
                      .scale(yScale)
                      .ticks(8);


          var line = d3.line()
                .x(function(d) {
                  return xScale(d.key); })
                .y(function(d) { return yScale(d.value); })


          var svgTimeline = d3.select("#timeline")
      						.append("svg")
      						.attr("width", width)
      						.attr("height", height);

          svgTimeline.append("text")
                  .attr("class", "xText label")
                  .attr("text-anchor", "middle")
                  .attr("x", width / 2)
                  .attr("y", height)
                  .text("Years");

          svgTimeline.append("text")
                  .attr("class", "yText label")
                  .attr("text-anchor", "middle")
                  .attr("y", 0)
                  .attr("x", - height / 2 - 20)
                  .attr("dy", ".75em")
                  .attr("transform", "rotate(-90)")
                  .text("# of inspections");

          svgTimeline.append("g")
                  .attr("class", "axis")
                  .attr("transform", "translate(0," + (height - padding) + ")")
                  .call(xAxis)

          svgTimeline.append("g")
                  .attr("class", "axis")
                  .attr("transform", "translate(" + (padding) + ",0)")
                  .call(yAxis)

          var circles = svgTimeline.append("g")
              .attr("id", "circles")
              .selectAll("circle")
              .data(NumberOfInspectionsPerDay)
              .enter()
              .append("circle")
              .attr("cx", function(d) {
                return xScale(d.key);
              })
              .attr("cy", function(d) {
                return yScale(d.value);
              })
              .attr("r", function(d) {
                return 0.5;
              })
              .attr("class", "non_brushed");

          svgTimeline.append("path")
                  .datum(NumberOfInspectionsPerDay)
                  .attr("class", "line")
                  .attr("d", line)
                  .attr("stroke-width",1)

          function isBrushed(brush_coords, cx) {

             var x0 = brush_coords[0],
                 x1 = brush_coords[1];

             return x0 <= cx && cx <= x1;
          }

          var brushedfunc = function() {
            if (d3.event.selection != null) {
                  // revert circles to initial style
                  circles.attr("class", "non_brushed");

                  var brush_coords = d3.brushSelection(this);
                  // style brushed circles
                  circles.filter(function (){

                             var cx = d3.select(this).attr("cx");

                             return isBrushed(brush_coords, cx);
                         })
                         .attr("class", "brushed");
              }
            displayData();
          }

          var displayData = function() {
            if (!d3.event.selection) return;

            // programmed clearing of brush after mouse-up
            // ref: https://github.com/d3/d3-brush/issues/10


            var d_brushed =  d3.selectAll(".brushed").data();
            var count = 0;
            for (var i = 0; i < d_brushed.length; i++) {
              count = count + d_brushed[i].value;
            }
            var startDate = d_brushed[0].key;
            var endDate = d_brushed[d_brushed.length-1].key;
            d_brushed = [];
            for (var i = 0; i < dataset.length; i++) {
              if (startDate <= dataset[i].InspectionDate && endDate >= dataset[i].InspectionDate) {
                d_brushed.push(dataset[i]);
              }
            }
            console.log(d_brushed);
            svgMap.selectAll('circle').remove();

            loadCircles(svgMap,d_brushed,projection,toolTip)

          };


          var brush = d3.brushX()
                        .extent([[padding, padding], [width-padding, height-padding]])
                        //.on("brush", brushFunction)
                        //.on("end", displayData);
                        .on("brush", brushedfunc);

          svgTimeline.append("g")
             .call(brush);

        }

        function loadMap(callback) {
          d3.json("NYC.json", function(json) {
              var projection = d3.geoMercator();
              var path = d3.geoPath().projection(projection);

              projection
                .scale(1)
                .translate([0, 0]);

              var b = path.bounds(json);
              var s = 1/Math.max((b[1][0] - b[0][0])/width, (b[1][1] - b[0][1])/height);
              var t = [ (width - s * (b[1][0] + b[0][0]))/2, (height - s * (b[1][1] + b[0][1]))/2];

              projection
                .scale(s)
                .translate(t);

              var svgMap = d3.select("#map")
              .append("svg")
              .attr("width", width)
              .attr("height", height);
              /*.call(d3.zoom().on("zoom", function () {
                svgMap.attr("transform", d3.event.transform);
                svgMap.selectAll("circle")
                  .attr("r", (width/300) * (1 / d3.event.transform.k));
              }))
              .append("g");*/

              svgMap.selectAll("path")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .style("fill", function(d) {
                   var value = d.properties.BoroCode-1;
                   return colors[value];
              });
              callback(json,path,projection,svgMap);
            });
        };

        var rowConverter = function(row) {
          return {
            Dba: row.DBA,
            Score: parseInt(row.SCORE),
            Grade: row.GRADE,
            InspectionDate: new Date(row["INSPECTION DATE"]),
            Lat: parseFloat(row.LAT),
            Long: parseFloat(row.LON)
          };
        };

        function handleMouseClick() {
          console.log("Circle Clicked!");

        }

        function handleMouseOver() {
          d3.select(this)
            .attr("fill","red")
            .attr("r", width/150);

        };

        function handleMouseOut() {
          d3.select(this)
            .attr("fill","black")
            .attr("r", width/300);
        }

        function loadCircles(svgMap,data,projection,tooltip) {

          var maxScore = d3.max(data, function(d) { return d.Score;});
          var colorScale = d3.scaleLinear()
                        .domain([0,20])
                        .range([310,200]);

          svgMap.append("g")
              .selectAll("circle")
              .data(data)
              .enter()
              .append("circle")
              .attr("cx", function(d) {
                return projection([d.Long, d.Lat])[0];
              })
              .attr("cy", function(d) {
                return projection([d.Long, d.Lat])[1];
              })
              .attr("r", function(d) {
                return width/300;
              })
              .attr("fill", function(d) {
                if(isNaN(d.Score)) return "black";
                else if(colorScale(d.Score) < 200){
                  return d3.hsl(200,100,50);
                }else {
                  return d3.hsl(colorScale(d.Score),100,50);
                }
              })
              .on("click", handleMouseClick)
              .on("mouseover", function(d) {
                d3.select(this)
                  .attr("r", width/150);
                  tooltip.transition()
                       .duration(200)
                       .style("opacity", .9);
                  tooltip.html(d.Dba + "<br/>" + "Score: " + d.Score + "<br/>" + "Grade: " + d.Grade)
                       .style("left", (d3.event.pageX + 5) + "px")
                       .style("top", (d3.event.pageY - 28) + "px");
              })
              .on("mouseout", function(d) {
                d3.select(this)
                  .attr("r", width/300);
                  tooltip.transition()
                       .duration(500)
                       .style("opacity", 0);
              });
        }

        function sortandCutArray(dataset) {
            dataset.sort(function(a, b) {
              var keyA = new Date(a.InspectionDate);
              var keyB = new Date(b.InspectionDate);
              if(keyA < keyB) return -1;
              if(keyA > keyB) return 1;
              return 0;
            });

            var cut = new Date(1901,0,01);
            for (var i = 0; i < dataset.length; i++) {
              if(isNaN(dataset[i].Long) || isNaN(dataset[i].Lat) || dataset[i].InspectionDate < cut) {
                dataset.splice(i,1);
                i = i - 1;
              }
            }
          };

        d3.csv("./data/dataset.csv", rowConverter, function(data) {
          sortandCutArray(data);

          loadMap(function(json,path,projection,svgMap) {
            var toolTip = createTooltip();
            loadCircles(svgMap,data,projection,toolTip);
            loadTimeline(data,projection,svgMap,toolTip);
          });
        });
    		</script>

    </body>
</html>
